<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec2 aPosition;

    void main(void) {
        gl_Position = vec4(aPosition, 0.0, 1.0);
    }
</script>
<title>CS 428 - Project 2- Snowflake</title>
<div class="header">
    <h1>Knoch Snowflake</h1>
    <p>Creates a Knoch triangle by adding triables to line segments</p>
  </div>
<script id="shader-fs" type="x-shader/x-fragment">
    void main(void) {
        gl_FragColor = vec4(0.0, 255.0, 255.0, 1.0);
    }
</script>

<script type="text/javascript">
    var SNOWFLAKE_ITERATIONS = 5;
    var SIZEOFSNOWFLAKE = 1.5;
    
    // scale of child triangle
    var SNOWFLAKESCALE = 1 / 3;
    var canvas;
    var gl;
    // Vertices
    var snowflakeVerticies;  
    // Buffer storing the snowflake's vertices
    var snowflakeVertexBuffer; 
    // Vertex shader attribute
    var aPositionAttrib;
    
    // Initialize the snowflake
    function initSnowflakeVertices()
     {
        var t1Side = SIZEOFSNOWFLAKE;
        var t2Side = t1Side * SNOWFLAKESCALE;
        var t1Height = eqTriHeight(t1Side);
        var t2Height = eqTriHeight(t2Side); 
        var snowFlakeHeight = t1Height + t2Height;
        var base = vec2(0.0, t2Height - snowFlakeHeight / 2); 
        var t1Dir = vec2(0.0, 1.0);
        var t2Dir = vec2(0.0, -1.0);
        var t1 = MakeKochTriangle(base, t1Dir, t1Side, SNOWFLAKE_ITERATIONS);
        var t2 = MakeKochTriangle(base, t2Dir, t2Side, SNOWFLAKE_ITERATIONS - 1);
       //concating the bottom knoch snowflake to triangle
     snowflakeVerticies = t1.concat(t2);
    }
    
    // Initialize the shader program
    function initShaders() 
    {
        var shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, compileShader("shader-fs"));
        gl.attachShader(shaderProgram, compileShader("shader-vs"));
        gl.linkProgram(shaderProgram);
        gl.useProgram(shaderProgram);
        
        aPositionAttrib = gl.getAttribLocation(shaderProgram, "aPosition");
        gl.enableVertexAttribArray(aPositionAttrib);
    }
    
    // Initialize a buffer and put the vertices in it
    function initBuffers() {
        snowflakeVertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, snowflakeVertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(snowflakeVerticies), gl.STATIC_DRAW);
    }
      // Creating vertices of an equilateral triangle.
      function eqTri(basePos, dir, sideLength) {
        var height = eqTriHeight(sideLength);
        var leftVert = dir.rotate90DegreesCCW().scale(sideLength / 2).plus(basePos);
        var rightVert = dir.rotate90DegreesCW().scale(sideLength / 2).plus(basePos);
        var topVert = dir.scale(height).plus(basePos);
        return [
            leftVert.x, leftVert.y,
            rightVert.x, rightVert.y,
            topVert.x, topVert.y
        ];
    }
    
    // Create the vertices of a Koch triangle
    function MakeKochTriangle(basePos, dir, sideLength, iterations) {
        var tri = eqTri(basePos, dir, sideLength);
        var leftVert = vec2(tri[0], tri[1]);
        var rightVert = vec2(tri[2], tri[3]);
        var topVert = vec2(tri[4], tri[5]);  
        if (iterations == 1) {
            return tri;
        } else {
            var leftBase = midpoint(leftVert, topVert);
            var leftDir = topVert.minus(leftVert).rotate90DegreesCCW().normalize();
            var leftTri = MakeKochTriangle(leftBase, leftDir, sideLength * SNOWFLAKESCALE, iterations - 1);
            
            var rightBase = midpoint(rightVert, topVert);
            var rightDir = topVert.minus(rightVert).rotate90DegreesCW().normalize();
            var rightTri = MakeKochTriangle(rightBase, rightDir, sideLength * SNOWFLAKESCALE, iterations - 1);
            
            return tri.concat(leftTri).concat(rightTri);
        }
    }
    
//2d vector class
    function vec2(x, y) {
        var v = {x: x, y: y};       
        v.plus = function(w) {
            return vec2(v.x + w.x, v.y + w.y);
        };        
        v.minus = function(w) {
            return vec2(v.x - w.x, v.y - w.y);
        };        
        v.scale = function(a) {
            return vec2(v.x * a, v.y * a);
        };        
        v.rotate90DegreesCW = function() {
            return vec2(v.y, -v.x);
        };        
        v.rotate90DegreesCCW = function() {
            return vec2(-v.y, v.x);
        };       
        v.normalize = function() {
            return v.scale(1 / v.length());
        };      
        v.length = function() {
            return Math.sqrt(v.x * v.x + v.y * v.y);
        };  
        return v;
    }
    // returns the shader in the current element.
    function compileShader(id) {
        var script = document.getElementById(id);
        if (!script) {
            return null;
        }

        var str = "";
        var j = script.firstChild;
        while (j) {
            if (j.nodeType == 3) {
                str += j.textContent;
            }
            j = j.nextSibling;
        }

        var shader;
        if (script.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (script.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

        gl.shaderSource(shader, str);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            console.error(id, gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }
    function eqTriHeight(sideLength) {
        return Math.sqrt(3) / 2 * sideLength;
    }
    
      // Returns the midpoint of the two vectors
      function midpoint(v, w) {
        return v.plus(w).scale(1 / 2);
    }
        
    function drawScene() {
        gl.clearColor(10.0, 10.0, 10.0, 0.0);
        gl.clear(gl.COLOR_BUFFER_BIT);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, snowflakeVertexBuffer);
        gl.vertexAttribPointer(aPositionAttrib, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLES, 0, snowflakeVerticies.length / 2);
    }
    
    function main() {
        canvas = document.getElementById("canvas");
        gl = canvas.getContext("webgl");
        initSnowflakeVertices();
        initShaders();
        initBuffers();
        drawScene();
    }
    
</script>

<body onload="main();">
    <canvas id="canvas" width="250" height="250"></canvas>
</body>